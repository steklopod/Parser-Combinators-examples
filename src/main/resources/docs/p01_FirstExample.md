## Уровень 2: Reverse Russian Notation Calculator 

Теперь мы готовы изучить более сложный пример.

_Одной из наиболее распространенных вещей, с которыми вы сталкиваетесь во время разработки программного 
обеспечения, является необходимость анализа произвольного текста для данных. Как правило, 
вы можете использовать `регулярные выражения` или `кодировать исходя из предположения о формате данных` о том, 
как вы анализируете текст (обрезать строку по определенным индексам, разделить по запятой и т.д.). 
**Оба способа хрупкие** и требуют большого количества подробного кода для правильной обработки всех 
возможных точек отказа. Это может привести к написанию собственного анализатора, если вы достаточно уверены,
 но это большая задача для большинства разработчиков. Вам нужно научиться писать парсер или изучать 
 генератор парсера, чтобы даже начать кодирование решения в вашем конкретном случае использования. 
 Однако Scala имеет фантастическое решение этой проблемы, и это решение представляет собой 
 **`комбинаторы парсеров`**._
 
 >Что такое комбинаторы парсеров?
 
 Начнем с того, что разберем термин на части, **`парсеры`** и **`комбинаторы`** и объясним, что это 
 на самом деле, если вы не в курсе. 
 
 **`Парсер`** - это функция, которая принимает поток входных токенов 
 и преобразует их в формат (как правило, структуру данных, такую как список или дерево), 
 которая более легко потребляется вашим приложением. 
 
 **`Комбинатор`** - это просто функция более высокого порядка, которая объединяет две функции в новую функцию. 
 
 **`Комбинатор парсеров`** - это просто функция, которая объединяет два парсера в другой парсер.

>Как их использовать?

Мы собираемся построить калькулятор `Reverse Russian Notation` в качестве примера того, 
как применять компараторы. Во-первых, я хочу перейти к доступным комбинаторам, которые мы собираемся 
использовать в этом примере:

* **`|`** является комбинатором чередования. Он говорит: _«Успешно, если успешно закончить анализ слева 
или справа»_

* **`~`** - последовательный комбинатор. Он говорит: _«Успешно, если левый операнд успешно разбирает, 
а затем правильно разбирает на оставшемся входе»_

* **`~>`** - говорит _«Успешно, если левый операнд успешно разбирает, а затем справа, но не включает 
левое содержимое в результат»_

* **`<~`** - обратное _"Успешно, если левый операнд успешно разбирается, а затем справа, 
но не включает в себя правильный контент в результате"_

* **`^^`** - комбинатор преобразований. В нем говорится: _«Если левый операнд успешно разбирается, 
преобразуйте результат, используя функцию справа»_

* **`rep`** - просто говорит: _«Ожидайте повторения N-много парсера X», где X - синтаксический анализатор,
 переданный как аргумент **`rep`**_

Теперь, когда мы рассмотрели, что представляют собой доступные комбинаторы, наш первый шаг - 
определить, как разбирать число:

<!-- code -->
```scala
    import scala.util.parsing.combinator._
    
    class ReverseRussianCalculator extends JavaTokenParsers {
        def num: Parser[Float] = floatingPointNumber ^^ (_.toFloat)
    }
```


[переведено мной отсюда](http://bitwalker.org/posts/2013-08-10-learn-by-example-scala-parser-combinators)

[еще пример](http://www.codecommit.com/blog/scala/the-magic-behind-parser-combinators)
