## Калькулятор [Обратной польской записи](https://ru.wikipedia.org/wiki/%D0%9E%D0%B1%D1%80%D0%B0%D1%82%D0%BD%D0%B0%D1%8F_%D0%BF%D0%BE%D0%BB%D1%8C%D1%81%D0%BA%D0%B0%D1%8F_%D0%B7%D0%B0%D0%BF%D0%B8%D1%81%D1%8C)  

Обра́тная по́льская запись (англ. Reverse Polish notation, RPN) — форма записи математических и логических выражений, 
в которой операнды расположены перед знаками операций. Также именуется как обратная польская запись, 
обратная бесскобочная запись, постфиксная нотация, бесскобочная символика Лукасевича, польская инверсная запись, ПОЛИЗ.
![alt text](https://upload.wikimedia.org/wikipedia/commons/thumb/a/a6/Postfix-dia.svg/125px-Postfix-dia.svg.png "Обра́тная по́льская запись")

Стековой машиной называется алгоритм, проводящий вычисления по обратной польской записи.

>Уровень 2

Стоит еще раз повторить основные понятия:

**Парсер** - это функция, которая принимает поток входных токенов 
и преобразует их в формат (как правило, структуру данных, такую как список или дерево), 
которая более легко потребляется вашим приложением. 

**Комбинатор** - это просто функция более высокого порядка, которая объединяет две функции в новую функцию. 

**Комбинатор парсеров** - это просто функция, которая объединяет два парсера в другой парсер.

>Как их использовать?

Мы создадим калькулятор `Reverse Russian Notation` в качестве примера того, 
как применять комбинатор парсеров. Доступные комбинаторы:

* **`|`** - комбинатор чередования.  _Успешно, если операнд либо слева, либо справа распаршен_;

* **`~`** - последовательный комбинатор. _Успешно, если `левый операнд успешно распаршен, а затем переходим к правому`_;

* **`^^`** - комбинатор преобразований. _Если левый операнд успешно распаршен, преобразовать результат, `используя функцию справа`_;

* **`~>`** - _Успешно, если `левый операнд успешно распаршен, а затем справа`, но не включает левое содержимое в результат_;

* **`<~`** - обратное _"Успешно, если `левый операнд успешно распаршен, а затем справа, 
но не включает в себя правый` контент в результате"_;

* **`rep(p)`** - _Повторить n-раз парсер `p`, пока не возникнет ошибка_ 

Первый шаг - определить, как разбирать число:

<!-- code -->
```scala
    import scala.util.parsing.combinator._
    
    class ReversePolishCalculator extends JavaTokenParsers {
        def num: Parser[Float] = floatingPointNumber ^^ (_.toFloat)
    }
```
Итак, мы импортируем комбинаторы парсеров и создаем класс с парсером чисел. Мы расширяем **JavaTokenParsers**, чтобы 
иметь возможность анализировать текст и получать доступ к парсеру `floatingPointNumber`. Функция `num` будет соответствовать 
любому числу с плавающей запятой и преобразует ее в `Float`. Парсер `floPointNumber` просто матчит текст, он не выполняет 
никакого преобразования. Если вы посмотрите на его исходный код, вы увидите, что это просто парсер регулярного выражения:

<!-- code -->
```scala
    trait JavaTokenParsers extends RegexParsers {
        def floatingPointNumber: Parser[String] = {
            """-?(\d+(\.\d*)?|\d*\.\d+)([eE][+-]?\d+)?[fFdD]?""".r
        }
    }
```

Поэтому на данный момент наш парсер может соответствовать числу, вот и все. Если это все, что мы хотели, 
мы могли бы объект для синтаксического анализа чисел:

<!-- code -->
```scala
object Calculator extends ReversePolishCalculator with App {
    val result = parseAll(num, "123.09")
    println(s"Parsed $result")
}
```
И получили бы след. результат:

<!-- code -->
```bash
  Parsed [1.7] parsed: 123.09
```

Это, в основном, бесполезно, поэтому давайте продолжим и определим, как анализировать операторы, которые может 
использовать наш калькулятор:

<!-- code -->
```scala
    class ReversePolishCalculator extends JavaTokenParsers {
        def num: Parser[Float] = floatingPointNumber ^^ (_.toFloat)
        def operator: Parser[(Float, Float) => Float] = ("*" | "/" | "+" | "-") ^^ {
            case "+" => (x, y) => x + y
            case "-" => (x, y) => x - y
            case "*" => (x, y) => x * y
            case "/" => (x, y) => if (y > 0) (x / y) else 0f
        }
    }
```


[переведено мной отсюда](http://bitwalker.org/posts/2013-08-10-learn-by-example-scala-parser-combinators)

[еще пример для самых умных](http://www.codecommit.com/blog/scala/the-magic-behind-parser-combinators)
